<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharsetForStandardCharset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Require Charset</a> &gt; <a href="index.source.html" class="el_package">com.github.gantsign.errorprone.require.charset</a> &gt; <span class="el_source">CharsetForStandardCharset.java</span></div><h1>CharsetForStandardCharset.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 GantSign Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package com.github.gantsign.errorprone.require.charset;

import static com.google.common.collect.Maps.immutableEntry;
import static com.google.errorprone.BugPattern.Category.JDK;
import static com.google.errorprone.BugPattern.MaturityLevel.MATURE;
import static com.google.errorprone.BugPattern.SeverityLevel.ERROR;
import static com.google.errorprone.fixes.SuggestedFix.replace;
import static com.google.errorprone.matchers.Matchers.methodInvocation;
import static com.google.errorprone.matchers.Matchers.staticMethod;
import static java.lang.String.format;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toMap;

import com.google.auto.service.AutoService;
import com.google.common.collect.ImmutableMap;
import com.google.errorprone.BugPattern;
import com.google.errorprone.VisitorState;
import com.google.errorprone.bugpatterns.BugChecker;
import com.google.errorprone.bugpatterns.BugChecker.MethodInvocationTreeMatcher;
import com.google.errorprone.matchers.Description;
import com.google.errorprone.matchers.Matcher;
import com.sun.source.tree.ExpressionTree;
import com.sun.source.tree.LiteralTree;
import com.sun.source.tree.MethodInvocationTree;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Map.Entry;
import java.util.stream.Stream;

/**
 * Bug checker to detect usage of {@link Charset#forName(String)} that can be replaced with
 * {@link StandardCharsets}.
 */
@AutoService(BugChecker.class)
@BugPattern(
    name = &quot;CharsetForStandardCharset&quot;,
    summary =
        &quot;Must use java.nio.charset.StandardCharsets where possible.&quot;,
    category = JDK,
    severity = ERROR,
    maturity = MATURE)
<span class="fc" id="L57">public class CharsetForStandardCharset</span>
    extends BugChecker
    implements MethodInvocationTreeMatcher {

<span class="fc" id="L61">  private static final String STANDARD_CHARSETS = StandardCharsets.class.getName();</span>
<span class="fc" id="L62">  private static final String CHARSET = Charset.class.getName();</span>
<span class="fc" id="L63">  private static final String STRING = String.class.getName();</span>

<span class="fc" id="L65">  private static final Matcher&lt;ExpressionTree&gt; method = methodInvocation(</span>
<span class="fc" id="L66">      staticMethod().onClass(CHARSET).named(&quot;forName&quot;).withParameters(STRING));</span>

  private static final ImmutableMap&lt;Charset, String&gt; STANDARD_CHARSET_FIELD_MAP =
<span class="fc" id="L69">      ImmutableMap.&lt;Charset, String&gt;builder()</span>
<span class="fc" id="L70">          .put(StandardCharsets.US_ASCII, &quot;US_ASCII&quot;)</span>
<span class="fc" id="L71">          .put(StandardCharsets.ISO_8859_1, &quot;ISO_8859_1&quot;)</span>
<span class="fc" id="L72">          .put(StandardCharsets.UTF_8, &quot;UTF_8&quot;)</span>
<span class="fc" id="L73">          .put(StandardCharsets.UTF_16BE, &quot;UTF_16BE&quot;)</span>
<span class="fc" id="L74">          .put(StandardCharsets.UTF_16LE, &quot;UTF_16LE&quot;)</span>
<span class="fc" id="L75">          .put(StandardCharsets.UTF_16, &quot;UTF_16&quot;)</span>
<span class="fc" id="L76">          .build();</span>

<span class="fc" id="L78">  private static final ImmutableMap&lt;String, Charset&gt; STANDARD_CHARSET_MAP =</span>
<span class="fc" id="L79">      STANDARD_CHARSET_FIELD_MAP.keySet()</span>
<span class="fc" id="L80">          .stream()</span>
<span class="fc" id="L81">          .flatMap(charset -&gt;</span>
<span class="fc" id="L82">              Stream.concat(</span>
<span class="fc" id="L83">                  Stream.of(immutableEntry(charset.name(), charset)),</span>
<span class="fc" id="L84">                  charset.aliases()</span>
<span class="fc" id="L85">                      .stream()</span>
<span class="fc" id="L86">                      .map(alias -&gt; immutableEntry(alias, charset))))</span>
<span class="fc" id="L87">          .map(entry -&gt; immutableEntry(entry.getKey().toLowerCase(), entry.getValue()))</span>
<span class="fc" id="L88">          .collect(collectingAndThen(toMap(Entry::getKey, Entry::getValue), ImmutableMap::copyOf));</span>

  private static boolean isStandardCharset(String name) {
<span class="fc" id="L91">    return STANDARD_CHARSET_MAP.containsKey(requireNonNull(name).toLowerCase());</span>
  }

  private static String fieldNameForCharset(String name) {
<span class="fc" id="L95">    Charset charset = STANDARD_CHARSET_MAP.get(requireNonNull(name).toLowerCase());</span>
<span class="fc" id="L96">    return STANDARD_CHARSET_FIELD_MAP.get(requireNonNull(charset));</span>
  }

  @Override
  public Description matchMethodInvocation(MethodInvocationTree tree, VisitorState state) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">    if (!method.matches(tree, state)) {</span>
<span class="fc" id="L102">      return Description.NO_MATCH;</span>
    }

<span class="fc" id="L105">    ExpressionTree name = tree.getArguments().get(0);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">    if (!(name instanceof LiteralTree)) {</span>
<span class="fc" id="L107">      return Description.NO_MATCH;</span>
    }

<span class="fc" id="L110">    LiteralTree literal = (LiteralTree) name;</span>
<span class="fc" id="L111">    String value = (String) literal.getValue();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (!isStandardCharset(value)) {</span>
<span class="fc" id="L113">      return Description.NO_MATCH;</span>
    }

<span class="fc" id="L116">    Description.Builder builder = buildDescription(tree);</span>

<span class="fc" id="L118">    String fieldName = requireNonNull(fieldNameForCharset(value));</span>

<span class="fc" id="L120">    String suggestion = format(&quot;%s.%s&quot;, STANDARD_CHARSETS, fieldName);</span>
<span class="fc" id="L121">    builder.addFix(replace(tree, suggestion));</span>
<span class="fc" id="L122">    return builder.build();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>